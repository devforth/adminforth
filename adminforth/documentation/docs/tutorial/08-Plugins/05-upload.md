# Upload

This plugin allows you to upload files to Amazon S3 bucket.

## Installation

```
npm i @adminforth/upload --save
```

Plugin needs some storage adapter to store files and serve them for preview.

### Using Amazon S3 storage adapter

Amazon S3 is probably the most popular storage service.

```
npm i @adminforth/storage-adapter-amazon-s3 --save
```

1. Go to https://aws.amazon.com and login.
2. Go to Services -> S3 and create a bucket. Put in bucket name e.g. `my-reality-bucket`. 
Leave all settings unchanged (ACL Disabled, Block all public access - checked)
3. Go to bucket settings, Permissions, scroll down to Cross-origin resource sharing (CORS) and put in the following configuration:

```json
[
    {
        "AllowedHeaders": [
            "*"
        ],
        "AllowedMethods": [
            "HEAD",
            "PUT",
            "GET"
        ],
        "AllowedOrigins": [
            "http://localhost:3500"
        ],
        "ExposeHeaders": []
    }
]
```

> ☝️ In AllowedOrigins add all your domains. For example if you will serve admin on `https://example.com/admin` you should add 
> `"https://example.com"` to AllowedOrigins:
>
> ```json
> [
>      "https://example.com",
>      "http://localhost:3500"
> ]
> ```
> Every character matters, so don't forget to add `http://` or `https://`!

4. Go to Services -> IAM and create a new user. Put in user name e.g. `my-reality-user`.
5. Attach existing policies directly -> `AmazonS3FullAccess`. Go to your user -> `Add permissions` -> `Attach policies directly` -> `AmazonS3FullAccess`
6. Go to Security credentials and create a new access key. Save `Access key ID` and `Secret access key`.
7. Add credentials in your `.env` file:

```ts title=".env"
...
NODE_ENV=development 

//diff-add
AWS_ACCESS_KEY_ID=your_access_key_id
//diff-add
AWS_SECRET_ACCESS_KEY=your_secret_access_key
```

8. Add credentials in your `.env.local` file:

```ts title=".env.local"
...
//diff-add
AWS_REGION=your_bucket_region
//diff-add
AWS_BUCKET_NAME=your_bucket_name
```

Now add a column for storing the path to the file in the database, add this statement to the `./schema.prisma`:

```ts title="./schema.prisma"
model apartments {
  id                String     @id
  created_at        DateTime? 
  title             String 
  square_meter      Float?
  price             Decimal
  number_of_rooms   Int?
  description       String?
  country           String?
  listed            Boolean
  realtor_id        String?
//diff-add
  apartment_image   String?
}
```

Migrate prisma schema:

```bash
npm run makemigration -- --name add-apartment-image ; npm run migrate:local
```

Add column to `aparts` resource configuration:

```ts title="./resources/apartments.ts"
//diff-add
import UploadPlugin from '@adminforth/upload';
//diff-add
import AdminForthAdapterS3Storage from '@adminforth/storage-adapter-amazon-s3'
//diff-add
import { randomUUID } from 'crypto';

export const admin = new AdminForth({
  ...
  resourceId: 'aparts',
  columns: [
    ...
//diff-add
    {
//diff-add
      name: 'apartment_image',
//diff-add
      showIn: { all: true, filter: false }, // for create and edit pages plugin put's it's own file dropzone widget, for show and list pages it put's preview
//diff-add
    }
    ...
  ],
  plugins: [
    ...
  //diff-add
    new UploadPlugin({
    //diff-add
      storageAdapter: new AdminForthAdapterS3Storage({
      //diff-add
        bucket: process.env.AWS_BUCKET_NAME,
      //diff-add
        region: process.env.AWS_REGION,
      //diff-add
        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      //diff-add
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    //diff-add
      }),
    //diff-add
      pathColumnName: 'apartment_image',
    //diff-add
      allowedFileExtensions: ['jpg', 'jpeg', 'png', 'gif', 'webm', 'webp'],
    //diff-add
      maxFileSize: 1024 * 1024 * 20, // 20 MB
    //diff-add
      filePath: ({originalFilename, originalExtension, contentType}) => 
    //diff-add
            `aparts/${new Date().getFullYear()}/${randomUUID()}-${originalFilename}.${originalExtension}`,
  //diff-add
    })
//diff-add
  ]
  
  ...

});
```


Here you can see how the plugin works:

![alt text](upload_gif.gif)


This setup will upload files to S3 bucket with private ACL and save path to file (relative to bucket root) in `apartment_image` column.

Once you will go to show or list view of `aparts` resource you will see preview of uploaded file by using presigned temporary URLs
which are generated by plugin:


![alt text](Upload.png)


> ☝ When upload feature is used on record which already exists in database (from 'edit' page), filePath callback will
> receive additional parameter `record` with all values of record. Generally we don't recommend denormalizing any state
> of record into s3 path (and instead store links to unique path on s3 in the record field, like in example above).
> But if you are 100% sure this kind of sate will be static, you might link to it:
>
> ```ts
> filePath: ({originalExtension, record}) => `game_images/${record.static_game_code}.${originalExtension}`
> ```
>
> ! Please note that when upload is done from create view, record will be `undefined`.


If you want to draw such images in main non-admin app e.g. Nuxt, you should generate presigned URLs by yourself. Here is NodeJS an example of how to do it:

```ts
import AWS from 'aws-sdk';

const s3 = new AWS.S3({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: 'us-east-1',
});

export async function getPresignedUrl(s3Path: string): Promise<string> {
  return s3.getSignedUrlPromise('getObject', {
    Bucket: 'my-bucket',
    Key: s3Path,
    Expires: 60 * 60, // 1 hour
  });
}
```

Alternatively, if you don't want to generate presigned URLs, you might want to make all objects public. Then you will be able  concatenate backet base domain and path stored in db, and use it as source of image. Let's consider how to do it.

#### S3 upload with public access

1. First of all go to your bucket settings, Permissions, scroll down to Block public access (bucket settings for this bucket) and uncheck all checkboxes.
2. Go to bucket settings, Permissions, Object ownership and select "ACLs Enabled" and "Bucket owner preferred" radio buttons.

Then you can change ACL in plugin configuration:

```ts title="./index.ts"

  new UploadPlugin({
      storageAdapter: new AdminForthAdapterS3Storage({
        bucket: process.env.AWS_BUCKET_NAME,
        region: process.env.AWS_REGION,
        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
//diff-add
        s3ACL: 'public-read',
      }),
      pathColumnName: 'apartment_image',
      allowedFileExtensions: ['jpg', 'jpeg', 'png', 'gif', 'webm', 'webp'],
      maxFileSize: 1024 * 1024 * 20, // 20 MB
      filePath: ({originalFilename, originalExtension, contentType}) => 
            `aparts/${new Date().getFullYear()}/${randomUUID()}-${originalFilename}.${originalExtension}`,
    })
      
```

Now every uploaded file will be public so in your custom app you can easily concatenate bucket URL with `filePath` to get public URL:

```ts
export async function getPublicUrl(filePath: string): string {
  return `https://my-bucket.s3.${region}.amazonaws.com/${filePath}`
}
```

For preview in AdminForth plugin will still use presigned URLs, but you can change it by providing `previewUrl` function in plugin configuration:

```ts title="./index.ts"

  preview: {
//diff-add
      previewUrl: ({filePath}) => `https://my-bucket.s3.us-east-1.amazonaws.com/${filePath}`, 
  }
```
> Make sure that you change "my-bucket" and "us-east-1" to your own settings.


Also you might want to put CDN in front of your bucket, for example [CloudFlare](https://developers.cloudflare.com/support/third-party-software/others/configuring-an-amazon-web-services-static-site-to-use-cloudflare/). In this case
we recommend route all AdminForth previews over CDN as well for faster worm up and better performance.
If for example your domain is `my-domain.com` and you bucket has name `static.my-domain.com` you should change preview URL like this:

```ts title="./index.ts"

  preview: {
//diff-remove
      previewUrl: ({filePath}) => `https://my-bucket.s3.us-east-1.amazonaws.com/${filePath}`,

//diff-add
      previewUrl: ({filePath}) => `https://static.my-domain.com/${filePath}`,
  }
```

Also you will have to enable static website hosting in your bucket settings and set index.html and error.html to empty strings.

### Using local storage adapter

The local storage adapter saves files directly on the server’s filesystem and serves them through Express routes. It supports both public and private modes (with presigned URLs).

```
npm i @adminforth/storage-adapter-local --save
```

```ts title="./index.ts"
import LocalStorageAdapter from '@adminforth/storage-adapter-local';

new UploadPlugin({
  storageAdapter: new LocalStorageAdapter({
    fileSystemFolder: "./db/uploads",
    adminServeBaseUrl: "static/source",
    mode: "public", // or "private"
    signingSecret: process.env.ADMINFORTH_SECRET,
  }),
  pathColumnName: 'apartment_image',
  allowedFileExtensions: ['jpg', 'jpeg', 'png', 'gif', 'webm', 'webp'],
  maxFileSize: 1024 * 1024 * 20, // 20 MB
  filePath: ({originalFilename, originalExtension, contentType}) => 
        `aparts/${new Date().getFullYear()}/${randomUUID()}-${originalFilename}.${originalExtension}`,
})
```
> adminServeBaseUrl defines the public path prefix. If your AdminForth base URL is /admin, files will be accessible under /admin/static/source/&lt;key&gt;.


## API

### uploadFromBufferToNewRecord

In some cases you may want to upload a file directly from your backend (for example, a file generated by a background job or received from a webhook) without going through the browser. For this, the Upload plugin exposes the `uploadFromBufferToNewRecord` method.

You can code it as custom logic or you can simply reuse Upload plugin for this purpose as well.

This method uploads a file from a Node.js `Buffer`, automatically creates a record in the corresponding resource, and returns both the stored file path and a preview URL.

```ts title="./some-backend-service.ts"
import { admin } from './admin'; // your AdminForth instance

...
plugins: [
  new UploadPlugin({
    id: 'my_reports_plugin', // unique identifier for your plugin instance
    ....
  })
]
...

const plugin = admin.getPluginById('my_reports_plugin');

const { path, previewUrl } = await plugin.uploadFromBufferToNewRecord({
  filename: 'report.pdf',
  contentType: 'application/pdf',
  buffer, // Node.js Buffer with file content
  adminUser, // current admin user or system user
  recordAttributes: {
    title: 'Generated report',
    listed: false,
  },
});
```

- `uploadFromBufferToNewRecord` uses the configured storage adapter (S3, local, etc.) to store the file.
- It automatically creates a new record in the resource and stores the file path into the column defined by `pathColumnName`, together with any extra `recordAttributes` you pass.
- It returns an object `{ path, previewUrl }`, where `previewUrl` is the same URL that would be used for previews inside AdminForth.

> ⚠️ It is not recommended to upload large files from the backend using `uploadFromBuffer`, because the entire file must go through your server memory and network. For large uploads you should prefer frontend presigned uploads directly to storage. You can find an example of presigned upload flow using upload plugin in the Rich editor plugin source code (Rich editor actually uses Upload plugin to upload images in edited content).


### uploadFromBufferToExistingRecord

If you already have a record and just want to replace the file referenced in its `pathColumnName` field, you can use the `uploadFromBufferToExistingRecord` method. It uploads a file from a Node.js `Buffer`, updates the existing record, and returns the new file path and preview URL.

```ts title="./some-backend-service.ts"
const plugin = admin.getPluginById('my_reports_plugin');

const { path, previewUrl } = await plugin.uploadFromBufferToExistingRecord({
  recordId: existingRecordId, // primary key of the record to update
  filename: 'report.pdf',
  contentType: 'application/pdf',
  buffer,        // Node.js Buffer with file content
  adminUser,     // current admin user or system user
  extra: {},     // optional extra meta for your hooks / audit
});
```

- Uses the same storage adapter and validation rules as `uploadFromBufferToNewRecord` (file extension whitelist, `maxFileSize`, `filePath` callback, etc.).
- Does not create a new record – it only updates the existing one identified by `recordId`, replacing the value in `pathColumnName` with the new storage path.
- If the generated `filePath` would be the same as the current value in the record, it throws an error to help you avoid CDN/browser caching issues. To force a refresh, make sure your `filePath` callback produces a different key (for example, include a timestamp or random UUID).

> ⚠️ The same recommendation about large files applies here: avoid using `uploadFromBufferToExistingRecord` for very large uploads; prefer a presigned upload flow from the frontend instead.



## Image generation

Upload plugin supports AI generation for images. Yo use it you need to install image generation adapter.
For example for OpenAI models like `gpt-image-1.5` (or old `DALL-E` models):

```bash
npm i @adminforth/image-generation-adapter-openai
```



```ts title="./index.ts"
import ImageGenerationAdapterOpenAI from '@adminforth/image-generation-adapter-openai';

new UploadPlugin({
  ...
//diff-add
  generation: {
//diff-add
    countToGenerate: 2,  // how much images generate in one shot
//diff-add
    adapter: new ImageGenerationAdapterOpenAI({
  //diff-add
      openAiApiKey: process.env.OPENAI_API_KEY as string,
  //diff-add
      model: 'gpt-image-1.5', 
  //diff-add
    }),
//diff-add
    generationPrompt: "Generate image for apartment with title {{title}} and description {{description}}",
//diff-add
    outputSize: '1536x1024' // size of generated image

},
```

Here is how it works:

![alt text](demoImgGen-1.gif)

You can also pass additional parameters to [OpenAI API call](https://platform.openai.com/docs/api-reference/images/createEdit) by using `extraParams` property:


```ts title="./apartments.ts"
new ImageGenerationAdapterOpenAI({
  //diff-add
    openAiApiKey: process.env.OPENAI_API_KEY as string,
  //diff-add
    model: 'gpt-image-1.5', 
  //diff-add
    extraParams: {
  //diff-add
      moderation: 'low',
  //diff-add
      quality: 'high',  
  //diff-add
    },
  //diff-add
    outputSize: '1536x1024' // size of generated image
}),
```


## Images editing or post-processing

You can not only generate images from text, but also edit, post-process or improve existing images. E.g. remove texts, add objects, change colors, etc.

Create a new column `apartment_source` in `apartments` table, and put another instance of `UploadPlugin` in the same resource configuration.


Now tweak the current UploadPlugin configuration in a next way:


```ts title="./apartments.ts"
generation: {
  adapter: new ImageGenerationAdapterOpenAI({
    openAiApiKey: process.env.OPENAI_API_KEY as string,
  }),

  attachFiles: ({ record, adminUser }: { record: any; adminUser: AdminUser }) => {
    // attach apartment source image to generation, image should be public
    return [`https://tmpbucket-adminforth.s3.eu-central-1.amazonaws.com/${record.apartment_source}`];
  },
  generationPrompt: "Remove text from the image",
  countToGenerate: 3,
  outputSize: '1024x1024',
}
```

`attachFiles` function can return an array of URLs to images which will be used as input for image generation. 
URLs can be absolute HTTP URLs (should be public in this case) or data-URLs (`data:image/png;base64,<base64 content of image>`).

For example you can use `getKeyAsDataURL` function from any storage adapter to get image as data-URL:

```ts title="./apartments.ts"

import { StorageAdapter } from 'adminforth'

let sourceAdapter: StorageAdapter = null;

columns: [
  ...
  {
    name: 'source_image',
  },
  {
    name: 'destination_image',
  }
],
plugins: [ 
  ...
  new UploadPlugin({
    pathColumnName: 'apartment_source',
    storageAdapter: (sourcesAdapter = new LocalStorageAdapter({
      fileSystemFolder: "./db/uploads",
      mode: "public",
      adminServeBaseUrl: "static/source",
      signingSecret: process.env.ADMINFORTH_SECRET, // secret used to generate presigned URLs
    }), sourcesAdapter),
  }),
  new UploadPlugin({
    pathColumnName: 'apartment_image',
    storageAdapter: new LocalStorageAdapter({
      fileSystemFolder: "./db/uploads",
      mode: "public",
      adminServeBaseUrl: "static/source",
      signingSecret: process.env.ADMINFORTH_SECRET, // secret used to generate presigned URLs
    }),
    generation: {
      attachFiles: ({ record }) => {
        // get picture stored in apartment_source column as data-URL
        return [sourceAdapter.getKeyAsDataURL(record.apartment_source)];
      },
      generationPrompt: "Remove text from the image",
      countToGenerate: 3,
      outputSize: '1024x1024',
    }
  })
]
```

With thus setup you can upload image to `apartment_source` column, save entity and then generate new image by clicking on `Generate` button in the `apartment_image` to remove any text from the image.


### Rate limits

You can set rate limits for image generation per IP address:

```ts title="./index.ts"
new UploadPlugin({
  ...
  generation: {
    ...
  //diff-add
    rateLimit: {
      limit: '5/12h', // up to 5 times per 12 hour 
      errorMessage: 'You exhausted your image generation limit 5 times per 12 hours, please try again later',
    }
      ...
});
```

### Preview Image Size Configuration

You can set the maximum width for the preview image in the `./resources/apartments.ts` file by adding the `maxWidth` property to the `preview` configuration:

```ts title="./resources/apartments.ts"
  ...
  new UploadPlugin({
    storageAdapter: new AdminForthAdapterS3Storage({
        bucket: process.env.AWS_BUCKET_NAME,
        region: process.env.AWS_REGION,
        accessKeyId: process.env.AWS_ACCESS_KEY_ID,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
        s3ACL: "public-read",
    }),
    pathColumnName: 'apartment_image',
    allowedFileExtensions: ['jpg', 'jpeg', 'png', 'gif', 'webm', 'webp'],
    maxFileSize: 5 * 1024 * 1024, // 5MB
    filePath: ({originalFilename, originalExtension, contentType}) => 
      `aparts/${new Date().getFullYear()}/${randomUUID()}-${originalFilename}.${originalExtension}`,
    preview: {
      // Global width settings (applies to all views if specific view settings not provided)
      maxWidth: '200px',  // Maximum width for preview images
      minWidth: '200px',  // Minimum width for preview images

      // List view specific settings
      maxListWidth: '300px',  // Maximum width in list view
      minListWidth: '100px',  // Minimum width in list view

      // Show/detail view specific settings
      maxShowWidth: '200px',  // Maximum width in show view
      minShowWidth: '200px',  // Minimum width in show view
    
      ...
    }

  })
  
  ...

});
```

## Using plugin for uploading avatar

Let's say, that you want to use upload plugin for uploading avatar for each user.
To do this add avatar column to the user resource:


```ts title="./schema.prisma"
  model adminuser {
    id            String     @id
    email         String     @unique
    password_hash String
    role          String
    created_at    DateTime
    //diff-add
    avatar        String?
  }
```

Then make migration:

```bash
  npm run makemigration -- --name add-user-avatar-field ; npm run migrate:local
```

Add this column to the users resource:

```ts title="./resources/adminuser.ts"

...

columns: [
  
  ...

  //diff-add
  {
    //diff-add
    name: "avatar",
    //diff-add
    type: AdminForthDataTypes.STRING,
    //diff-add
    showIn: ["show", "edit", "create" ],
    //diff-add
  },

  ...

]

...

plugins: [

  ...

  //diff-add
  new UploadPlugin({
      //diff-add
    pathColumnName: "avatar",
      //diff-add
    storageAdapter: new AdminForthAdapterS3Storage({
      //diff-add
      bucket: process.env.AWS_BUCKET_NAME,
      //diff-add
      region: process.env.AWS_REGION,
      //diff-add
      accessKeyId: process.env.AWS_ACCESS_KEY_ID as string,
      //diff-add
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY as string,
      //diff-add
    }),
    //diff-add
    allowedFileExtensions: [
      //diff-add
      "jpg",
      //diff-add
      "jpeg",
      //diff-add
      "png",
      //diff-add
      "gif",
      //diff-add
      "webm",
      //diff-add
      "exe",
      //diff-add
      "webp",
      //diff-add
    ],
    //diff-add
    maxFileSize: 1024 * 1024 * 20, // 20MB
    //diff-add
    filePath: ({ originalFilename, originalExtension, contentType, record }) => {
      //diff-add
      return `aparts/${new Date().getFullYear()}/${originalFilename}.${originalExtension}`
      //diff-add
    },
    //diff-add
    preview: {
      //diff-add
      maxWidth: "200px",
      //diff-add
    },
    //diff-add
  }),

  ...

]

```

And finally add this callback:

```ts title="./index.ts"

  auth: {

    ...
    //diff-add
    avatarUrl: async (adminUser)=>{
      //diff-add
      const plugin = admin.getPluginsByClassName('UploadPlugin').find(p => p.pluginOptions.pathColumnName === 'avatar') as any; 
      //diff-add
      if (!plugin) {
        //diff-add
        throw new Error('Upload plugin for avatar not found');
        //diff-add
      }
      //diff-add
      if (adminUser.dbUser.avatar === null || adminUser.dbUser.avatar === undefined || adminUser.dbUser.avatar === '') {
        //diff-add
        return undefined;
        //diff-add
      }
      //diff-add
      const imageUrl = await plugin.getFileDownloadUrl(adminUser.dbUser.avatar || '', 3600);
      //diff-add
      return imageUrl;
      //diff-add
    },


    ...

  }

```

And now you can easily update avatar for each user